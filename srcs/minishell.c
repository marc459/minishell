
#include <minishell.h>

char *stripwhite (char *string)
{
	register char *s, *t;

	for (s = string; *s == ' '; s++)
	;

	if (*s == 0)
		return (s);

	t = s + strlen (s) - 1;
	while (t > s && *t == ' ')
	t--;
	*++t = '\0';

	return s;
}

int		main(int argc,char **argv, char **env)
{
	int status;
	pid_t	pid;
	char	*command;
	char *s;
	

	if(argc > 1)
		return (-1);
	signals();
	command = calloc(sizeof(char) * 64);
	/*ft_memset(command, '\0', 64);
	command = readline("Quineshell-1.0:");
	add_history (command);*/

	while (ft_strncmp(command, "exit", ft_strlen(command)))
	{
		pid = fork();
		if (pid == 0)
		{
			/** LEXER -> Reads de line and identify all the parts that component the comands, tokenising them **/

			/** PARSER -> Builds de command table and identify them as a (command, pipe, inputfile, outputfile, $expansionvars, redirecctions, *subshell* )**/ 
			parser(command);
	
			/** EXECUTOR **/
			/*
			The executor will take the command table generated by the parser and for every 
			SimpleCommand in the array it will create a new process. It will also if necessary create pipes 
			to communicate the output of one process to the input of the next one. Additionally, it will 
			redirect the standard input, standard output, and standard error if there are any redirections. 

					execve(comandpath, comand&&flags, NULL); 
					execve(comand, comand&&flags, NULL); 
			*/								
			execlp(command, command, NULL); 
			ft_printf("Quineshell: %s: command not found\n",command);
			free(command);
			exit(0);
		}
		else
		{
			if (pid > 0)
			{
				//waitpid(pid, &status, 0);
				wait(&status);
				ft_memset(command, '\0', 64);
				command = readline("Quineshell-1.0:");
				add_history (command);
			}
			else
				ft_printf("Error Fork\n");
		}
	}
	exit(0);
}
